import{_ as s,c as i,o as a,a3 as n}from"./chunks/framework.DC-ssQ6l.js";const E=JSON.parse('{"title":"Thinking in Ramda: 数据不变性和对象","description":"","frontmatter":{},"headers":[],"relativePath":"guide/Thinking-in-Ramda-Immutability-and-Objects.md","filePath":"guide/Thinking-in-Ramda-Immutability-and-Objects.md"}'),h={name:"guide/Thinking-in-Ramda-Immutability-and-Objects.md"},e=n(`<h1 id="thinking-in-ramda-数据不变性和对象" tabindex="-1">Thinking in Ramda: 数据不变性和对象 <a class="header-anchor" href="#thinking-in-ramda-数据不变性和对象" aria-label="Permalink to &quot;Thinking in Ramda: 数据不变性和对象&quot;">​</a></h1><p>译者注：本文翻译自 Randy Coulman 的 《<a href="http://randycoulman.com/blog/2016/06/28/thinking-in-ramda-immutability-and-objects/" target="_blank" rel="noreferrer">Thinking in Ramda: Immutability and Objects</a>》，转载请与<a href="https://github.com/randycoulman" target="_blank" rel="noreferrer">原作者</a>或<a href="https://github.com/adispring" target="_blank" rel="noreferrer">本人</a>联系。下面开始正文。</p><hr><p>本文是函数式编程系列文章：<a href="https://adispring.coding.me/categories/Thinking-in-Ramda/" target="_blank" rel="noreferrer">Thinking in Ramda</a> 的第六篇。</p><p>在 <a href="https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/" target="_blank" rel="noreferrer">第五节</a> 中，我们讨论了如何以 &quot;pointfree&quot; 或 &quot;tacit&quot; 风格来编写函数：函数的参数不会显式的出现。</p><p>那时候，因为缺少一些工具，我们还无法将所有的函数转换为 &quot;pointfree&quot; 的风格。现在我们就来学习这些工具。</p><h2 id="读取对象属性" tabindex="-1">读取对象属性 <a class="header-anchor" href="#读取对象属性" aria-label="Permalink to &quot;读取对象属性&quot;">​</a></h2><p>再来回顾一下 <a href="https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/" target="_blank" rel="noreferrer">第五节</a> 已经重构过的 &quot;合格选民&quot; 的例子：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wasBornInCountry</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person.birthCountry </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> OUR_COUNTRY</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wasNaturalized</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(person.naturalizationDate)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isOver18</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 18</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> isCitizen</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> either</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(wasBornInCountry, wasNaturalized)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> isEligibleToVote</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> both</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(isOver18, isCitizen)</span></span></code></pre></div><p>如上所示，我们已经将 <code>isCitizen</code> 和 <code>isEligibleToVote</code> 变为 &quot;pointfree&quot; 风格的了，但前三个函数还没有 &quot;pointfree&quot; 化。</p><p>正如 <a href="https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/" target="_blank" rel="noreferrer">第四节</a> 所学，可以使用 <code>equals</code> 和 <code>gte</code> 来让函数更 &quot;声明式&quot; 一些。我们就此开始：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wasBornInCountry</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> equals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(person.birthCountry, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OUR_COUNTRY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wasNaturalized</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(person.naturalizationDate)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isOver18</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> gte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(person.age, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>为了让这些函数变为 &quot;pointfree&quot; 的，需要一种方法来使构建出来的函数的 <code>person</code> 参数排在参数列表的最后。问题是，我们需要访问 <code>person</code> 的属性，现有唯一的方法却是命令式的。</p><h2 id="prop" tabindex="-1">prop <a class="header-anchor" href="#prop" aria-label="Permalink to &quot;prop&quot;">​</a></h2><p>幸运的是， Ramda 为我们提供了访问对象属性的辅助函数：<code>prop</code>。</p><p>使用 <code>prop</code>，可以将 <code>person.birthCountry</code> 转换为 <code>prop(&#39;birthCountry&#39;, person)</code>。现在来试试。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wasBornInCountry</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> equals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;birthCountry&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, person), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OUR_COUNTRY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wasNaturalized</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;naturalizationDate&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, person))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isOver18</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> gte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;age&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, person), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>哇！现在看起来更糟了，还需要继续重构。首先，需要交换传递给 <code>equals</code> 的参数的顺序，这样可以将 <code>prop</code> 放到最后。<code>equals</code> 在任意顺序下都能正常工作。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wasBornInCountry</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> equals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OUR_COUNTRY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;birthCountry&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, person))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wasNaturalized</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;naturalizationDate&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, person))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isOver18</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> gte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;age&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, person), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>接下来，使用 <code>equals</code> 和 <code>gte</code> 的柯里化特性来创建新函数，新函数可以作用于 <code>prop</code> 输出的结果上。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wasBornInCountry</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> equals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OUR_COUNTRY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;birthCountry&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, person))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wasNaturalized</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;naturalizationDate&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, person))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isOver18</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> gte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;age&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, person))</span></span></code></pre></div><p>还是不太好，还需要继续优化。我们继续利用柯里化的特性来优化 <code>prop</code> 的调用。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wasBornInCountry</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> equals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OUR_COUNTRY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;birthCountry&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(person))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wasNaturalized</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;naturalizationDate&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(person))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isOver18</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> gte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;age&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(person))</span></span></code></pre></div><p>又变糟了。但现在我们看到了一种熟悉的模式，所有的三个函数都具有相同的形式：<code>g(f(person))</code>。由 <a href="https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions" target="_blank" rel="noreferrer">第二节</a> 可知，这等价于 <code>compose(g, f)(person)</code>。</p><p>我们来利用这一点。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wasBornInCountry</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">equals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OUR_COUNTRY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;birthCountry&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))(person)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wasNaturalized</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Boolean, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;naturalizationDate&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))(person)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isOver18</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;age&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))(person)</span></span></code></pre></div><p>现在好一些了，三个函数的形式变成了 <code>person =&gt; f(person)</code>。由 <a href="https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style" target="_blank" rel="noreferrer">第五节</a> 可知，现在可以将这三个函数写成 &quot;pointfree&quot; 的了。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wasBornInCountry</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">equals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OUR_COUNTRY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;birthCountry&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wasNaturalized</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Boolean, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;naturalizationDate&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> isOver18</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;age&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><p>未重构前，并不能明显看出我们的方法是在做两件事情。它们都先访问对象的属性，然后对该属性的值进行一些操作。重构为 &quot;pointfree&quot; 风格后，程序的表意变得清晰了许多。</p><p>我们来展示更多 Ramda 处理对象的函数。</p><h2 id="pick" tabindex="-1">pick <a class="header-anchor" href="#pick" aria-label="Permalink to &quot;pick&quot;">​</a></h2><p><code>prop</code> 用来读取并返回对象的单个属性，而 <code>pick</code> 读取对象的多个属性，然后返回有这些属性组成的新对象。</p><p>例如，如果想同时获取一个人的名字和年龄，可以使用：<code>pick([&#39;name&#39;, &#39;age&#39;], person)</code>。</p><h2 id="has" tabindex="-1">has <a class="header-anchor" href="#has" aria-label="Permalink to &quot;has&quot;">​</a></h2><p>在不读取属性值的情况下，想知道对象中是否包含该属性，可以使用 <code>has</code> 来检测对象是否拥有该属性，如 <code>has(&#39;name&#39; ,person)</code>；还可以使用 <code>hasIn</code> 来检测原型链上的属性。</p><h2 id="path" tabindex="-1">path <a class="header-anchor" href="#path" aria-label="Permalink to &quot;path&quot;">​</a></h2><p><code>prop</code> 用来读取对象的属性，<code>path</code> 可以读取对象的嵌套属性。例如，我们可以从更深层的结构中访问邮编：<code>path([&#39;address&#39;, &#39;zipCode&#39;], person)</code>。</p><p>注意，<code>path</code> 容错性更强。如果路径上的任意属性为 <code>null</code> 或 <code>undefined</code>，则 <code>path</code> 返回 <code>undefined</code>，而 <code>prop</code> 会引发错误。</p><h2 id="propor-pathor" tabindex="-1">propOr / pathOr <a class="header-anchor" href="#propor-pathor" aria-label="Permalink to &quot;propOr / pathOr&quot;">​</a></h2><p><code>propOr</code> 和 <code>pathOr</code> 像是 <code>prop</code>/<code>path</code> 与 <code>defaultTo</code> 的组合。如果在目标对象中找不到属性或路径的值，它们允许你提供默认值。</p><p>例如，当我们不知道某人的姓名时，可以提供一个占位符：<code>propOr(&#39;&lt;Unnamed&gt;&#39;, &#39;name&#39;, person)</code>。注意，与 <code>prop</code> 不同，如果 <code>person</code> 为 <code>null</code> 或 <code>undefined</code> 时，<code>propOr</code> 不会引发错误，而是会返回一个默认值。</p><h2 id="keys-values" tabindex="-1">keys / values <a class="header-anchor" href="#keys-values" aria-label="Permalink to &quot;keys / values&quot;">​</a></h2><p><code>keys</code> 返回一个包含对象中所有属性名称的数组。<code>values</code> 返回这些属性的值组成的数组。当与 <a href="https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8" target="_blank" rel="noreferrer">第一节</a> 中提到集合迭代函数结合使用时，这两个函数会非常有用。</p><h2 id="对属性增、删、改、查" tabindex="-1">对属性增、删、改、查 <a class="header-anchor" href="#对属性增、删、改、查" aria-label="Permalink to &quot;对属性增、删、改、查&quot;">​</a></h2><p>现在已经有很多对对象进行声明式读取的函数，但如果想要进行更改操作呢？</p><p>由于数据不变性很重要，我们不想直接更改对象。相反，我们想要更改后形成的新对象。</p><p>Ramda 再次为我们提供了很多辅助函数。</p><h2 id="assoc-assocpath" tabindex="-1">assoc / assocPath <a class="header-anchor" href="#assoc-assocpath" aria-label="Permalink to &quot;assoc / assocPath&quot;">​</a></h2><p>在命令式编程时，可以使用赋值操作符设置或更改一个人的名字：<code>person.name = &#39;New name&#39;</code>。</p><p>在函数式、数据不变的世界里，可以使用 <code>assoc</code> 来代替：<code>const updatedPerson = assoc(&#39;name&#39;, &#39;New name&#39;, person)</code>。</p><p><code>assoc</code> 返回一个添加或修改属性的新对象，原对象保持不变。</p><p>还有用于更新嵌套属性的方法：<code>assocPath</code>：<code>const updatedPerson = assocPath([&#39;address&#39;, &#39;zipcode&#39;], &#39;97504&#39;, person)</code>。</p><h2 id="dissoc-dissocpath-omit" tabindex="-1">dissoc / dissocPath / omit <a class="header-anchor" href="#dissoc-dissocpath-omit" aria-label="Permalink to &quot;dissoc / dissocPath / omit&quot;">​</a></h2><p>如何删除属性呢？我们可能想删除 <code>person.age</code> 。在 Ramda 中，可以使用 <code>dissoc</code>：<code>const updatedPerson = dissoc(&#39;age&#39;, person)</code>。</p><p><code>dissocPath</code> 类似于 <code>dissoc</code>，但可以作用于对象的嵌套属性：<code>dissocPath([&#39;address&#39;, &#39;zipCode&#39;], person)</code>。</p><p>还有一个 <code>omit</code>，用于一次删除多个属性。<code>const updatedPerson = omit([&#39;age&#39;, &#39;birthCountry&#39;], person)</code>。</p><p>注意，<code>pick</code> 与 <code>omit</code> 的操作很像，两者是互补的关系。它们能辅助实现白名单（使用 <code>pick</code> 保留想要的属性集）和黑名单（使用 <code>omit</code> 删除不想要的属性集）的功能。</p><h2 id="属性转换" tabindex="-1">属性转换 <a class="header-anchor" href="#属性转换" aria-label="Permalink to &quot;属性转换&quot;">​</a></h2><p>我们现在已经知道如何利用声明式和数据不变性的方式来处理对象。我们来写一个函数：<code>celebrateBirthday</code>，在生日当前更新他的年龄。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nextAge</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(inc, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;age&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> celebrateBirthday</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> assoc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;age&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nextAge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(person), person)</span></span></code></pre></div><p>这是一种很常见的模式。如上所示，我们并不想用给定的新值覆盖已有属性值，而是想通过函数作用于属性的旧值来对其进行转换。</p><p>就目前已知的方法，我尚未找到一种以更少重复代码和 pointfree 的形式来优化该段代码的方式。</p><p>Ramda 使用 <code>evolve</code> 方法再次拯救了我们。我在 <a href="http://randycoulman.com/blog/2016/02/16/using-ramda-with-redux/" target="_blank" rel="noreferrer">之前的文章</a> 中也提到过 <code>evolve</code>。</p><p><code>evolve</code> 接受一个对象，其中包含对每个需要转换属性的转换函数。我们来使用 <code>evolve</code> 来重构 <code>celebrateBirthday</code>：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> celebrateBirthday</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> evolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ age: inc })</span></span></code></pre></div><p>这段代码通过将 <code>evolve</code> 参数对象属性对应的函数作用于被变换对象相同属性值上，来转换已有对象的属性。本例中使用 <code>inc</code> 对 <code>person</code> 的 <code>age</code> 属性进行加 1 操作，并返回 <code>age</code> 更新后的新 <code>person</code> 对象。</p><p><code>evolve</code> 可以一次转换多个属性，还可以进行嵌套转换。&quot;转换函数对象&quot;（包含转换函数的对象）与被转换对象具有基本相同的结构，<code>evolve</code> 会递归地遍历这两个对象，然后将转换函数作用于对应的属性值上。</p><p>注意，<code>evolve</code> 不会添加新属性，如果为目标对象不存在的属性指定转换函数，<code>evolve</code> 会将其忽略。</p><p><code>evolve</code> 已经很快成为我编程时的主力。</p><h2 id="合并对象" tabindex="-1">合并对象 <a class="header-anchor" href="#合并对象" aria-label="Permalink to &quot;合并对象&quot;">​</a></h2><p>有时，需要合并两个对象。一种常见的情形是当使用含有 &quot;options&quot; 配置项的函数时，常常需要将这些配置项与一组默认配置项进行组合。Ramda 为此提供了 <code>merge</code> 方法。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> defaultOptions</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { value: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, local: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> finalOptions</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> merge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(defaultOptions, options)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>merge</code> 返回一个包含两个对象的所有属性和值的新对象。如果两个对象具有相同的属性，则采用第二个对象参数的属性值。</p><p>在单独使用 <code>merge</code> 时，采用第二个参数的属性值作为最终值是非常有用的；但在 pipeline 中可能没什么用。在 pipeline 中，通常会对一个对象进行一系列转换，其中一个转换是合并一些新的属性值到对象中。这种情况，可能需要第一个参数中的属性值作为最终值。</p><p>如果只是在 pipeline 中简单地使用 <code>merge(newValues)</code>，可能不会得到你想要的结果。</p><p>对于这种情况，我通常会定义一个辅助函数 <code>reverseMerge</code>：<code>const reverseMerge = flip(merge)</code>。回想一下，<code>flip</code> 会翻转函数前两个参数的位置。</p><p><code>merge</code> 执行的是浅合并。如果被合并的对象存在属性值为对象的属性，子对象并不会继续嵌套合并。如果想递归地进行 &quot;深合并&quot;，可以使用 Ramda 的 <code>mergeDeep</code> 系列函数。（译者注：作者在写这篇文章时，Ramda 还没有 <code>mergeDeep</code> 系列函数，<code>mergeDeep</code> 系列函数是在 v0.24.0 中加入的）</p><p>注意，<code>merge</code> 只接受两个参数。如果想要将多个对象合并为一个对象，可以使用 <code>mergeAll</code>，它接受一个需要被合并对象的数组作为参数。</p><h2 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论&quot;">​</a></h2><p>本文展示了 Ramda 中一系列很好的以声明式和数据不变方式处理对象的方法。我们现在可以对对象进行增、删、改、查，而不会改变原有的对象。并且也可以在组合函数时使用这些方法来做这些事情。</p><h2 id="下一节" tabindex="-1">下一节 <a class="header-anchor" href="#下一节" aria-label="Permalink to &quot;下一节&quot;">​</a></h2><p>现在可以以 Immutable 的方式处理对象，那么数组呢？<a href="./Thinking-in-Ramda-Immutability-and-Arrays.html">数据不变性和数组</a> 将演示对数组的处理。</p>`,82),t=[e];function p(k,l,r,d,o,g){return a(),i("div",null,t)}const F=s(h,[["render",p]]);export{E as __pageData,F as default};
